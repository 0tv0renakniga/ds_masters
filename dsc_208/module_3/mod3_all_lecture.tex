\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{array}

\begin{document}

\section*{SQL}
\begin{itemize}
    \item Data Definition Language (DDL)
    \item Create/alter/delete tables and their attributes
    \item Data Manipulation Language (DML)
    \item Query one or more tables insert/delete/modify tuples in tables
    \item Triggers and Advanced Constraints
    \item Actions executed by DBMS on updates and specify complex integrity constraints
\end{itemize}

\section*{Basic SQL Query}
\begin{verbatim}
SELECT [DISTINCT] <column expression list>
FROM <list of tables>
WHERE <predicate>
\end{verbatim}
Specifies columns to be retained in the results

Specifies cross-product of tables

Specifies selection conditions on the tables mentioned in the FROM clause

The resulting table should not have duplicates (it's optional)

\section*{Projection in SQL}
Movie (name, year, genre)
ActedIN (actorname, moviename)

\begin{verbatim}
SELECT name, genre
FROM Movies
\end{verbatim}
Return movies names and their genres

\begin{tabular}{lll}
\hline
"Name" & "Year" & "Genre" \\
\hline
"Apocalypse Now" & "1989" & "War" \\
"The God Father" & "1972" & "Crime" \\
"Planet Earth II" & "2016" & "Nature Documentary" \\
\hline
\end{tabular}

\begin{tabular}{ll}
\hline
"Name" & "Genre" \\
\hline
"Apocalypse Now" & "War" \\
"The God Father" & "Crime" \\
"Planet Earth II" & "Nature Documentary" \\
\hline
\end{tabular}

\section*{Selection in SQL}
Movie (name, year, genre)
ActedIN (actorname, moviename)

\begin{verbatim}
SELECT *
FROM Movies
WHERE year > 2000
\end{verbatim}
\begin{tabular}{lll}
\hline
"Name" & "Year" & "Genre" \\
\hline
"Apocalypse Now" & "1989" & "War" \\
"The God Father" & "1972" & "Crime" \\
"Planet Earth II" & "2016" & "Nature" , "Documentary" \\
\hline
\end{tabular}

Return movies produced after 2000

\begin{tabular}{lll}
\hline
"Name" & "Year" & "Genre" \\
\hline
"Planet Earth II" & "2016" & "Nature" , "Documentary" \\
\hline
\end{tabular}

\section*{Selection and Projection in SQL}
Movie (name, year, genre)

\begin{tabular}{lll}
\hline
"Name" & "Year" & "Genre" \\
\hline
"Apocalypse Now" & "1989" & "War" \\
"The God Father" & "1972" & "Crime" \\
"Planet Earth II" & "2016" & "Nature Documentary" \\
\hline
\end{tabular}

ActedIN (actorname, moviename)

\begin{verbatim}
SELECT name
FROM Movies
WHERE year > 2000
\end{verbatim}
Return movie names produced after 2000

Name

Planet Earth II

\section*{What does this query return?  Joins in SQL}
\begin{verbatim}
SELECT DISTINCT genre
FROM Movie, ActedIN
WHERE movie.name=ActedIN.moviename
\end{verbatim}
\begin{tabular}{lll}
\hline
Name & Year & Genre \\
\hline
Apocalypse Now & 1979 & War \\
The God Father & 1972 & Crime \\
Planet Earth II & 2016 & Nature Documentary \\
\hline
\end{tabular}

\begin{tabular}{ll}
\hline
Actorname & Moviename \\
\hline
Marlon Brando & Apocalypse Now \\
Al Pacino & The God Father \\
Marlon Brando & The God Father \\
\hline
\end{tabular}

\newpage

\section*{Joins in SQL}
\begin{itemize}
    \item Inner Join
    \item Self Join
    \item Outer Join
\end{itemize}

\section*{Joins}
Return all movie genres that Marlon Brando has acted in

Movie (name, year, genre)
ActedIN (actorname, moviename)
Moviename = foreign key to Movie.name

\section*{(Inner) Joins}
Join Condition

Movie (name, year, genre)
ActedIN (actorname, moviename)

\begin{verbatim}
SELECT DISTINCT genre
FROM   Movie, ActedIN
WHERE  Movie.name=ActedIN.moviename AND
       ActedIN.actorname='Marlon Brando'
\end{verbatim}

\section*{(Inner) Joins}
\begin{verbatim}
SELECT DISTINCT genre
FROM   Movie, ActedIN
WHERE  Movie.name=ActedIN.moviename AND ActedIN.actorname='Marlon Brando'
\end{verbatim}

\begin{tabular}{lll}
\hline
"Name" & "Year" & "Genre" \\
\hline
"Apocalypse Now" & "1979" & "War" \\
"The God Father" & "1972" & "Crime" \\
"Planet Earth II" & "2016" & "Nature Documentary" \\
\hline
\end{tabular}

\begin{tabular}{ll}
\hline
"Actorname" & "Moviename" \\
\hline
"Marlon Brando" & "Apocalypse Now" \\
"Al Pacino" & "The God Father" \\
"Marlon Brando" & "The God Father" \\
\hline
\end{tabular}

\section*{(Inner) Joins}
\begin{verbatim}
SELECT DISTINCT genre
FROM   Movie, ActedIN
WHERE  Movie.name=ActedIN.moviename AND ActedIN.actorname='Marlon Brando'
\end{verbatim}

\begin{tabular}{lll}
\hline
"Name" & "Year" & "Genre" \\
\hline
"Apocalypse Now" & "1979" & "War" \\
"The God Father" & "1972" & "Crime" \\
"Planet Earth II" & "2016" & "Nature Documentary" \\
\hline
\end{tabular}

\begin{tabular}{ll}
\hline
"Actorname" & "Moviename" \\
\hline
"Marlon Brando" & "Apocalypse Now" \\
"Al Pacino" & "The God Father" \\
"Marlon Brando" & "The God Father" \\
\hline
\end{tabular}

\section*{(Inner) Joins}
\begin{verbatim}
SELECT DISTINCT genre
FROM   Movie, ActedIN
WHERE  Movie.name=ActedIN.moviename AND ActedIN.actorname='Marlon Brando'
\end{verbatim}

\begin{tabular}{lll}
\hline
"Name" & "Year" & "Genre" \\
\hline
"Apocalypse Now" & "1979" & "War" \\
"The God Father" & "1972" & "Crime" \\
"Planet Earth II" & "2016" & "Nature Documentary" \\
\hline
\end{tabular}

\begin{tabular}{ll}
\hline
"Actorname" & "Moviename" \\
\hline
"Marlon Brando" & "Apocalypse Now" \\
"Al Pacino" & "The God Father" \\
"Marlon Brando" & "The God Father" \\
\hline
\end{tabular}

\section*{(Inner) Joins}
\begin{verbatim}
SELECT DISTINCT genre
FROM   Movie, ActedIN
WHERE  Movie.name=ActedIN.moviename AND ActedIN.actorname='Marlon Brando'
\end{verbatim}

\begin{tabular}{lll}
\hline
"Name" & "Year" & "Genre" \\
\hline
"Apocalypse Now" & "1979" & "War" \\
"The God Father" & "1972" & "Crime" \\
"Planet Earth II" & "2016" & "Nature Documentary" \\
\hline
\end{tabular}

\begin{tabular}{ll}
\hline
"Actorname" & "Moviename" \\
\hline
"Marlon Brando" & "Apocalypse Now" \\
"Al Pacino" & "The God Father" \\
"Marlon Brando" & "The God Father" \\
\hline
\end{tabular}

\begin{tabular}{lllll}
\hline
"Name" & "Year" & "Genre" & "Actorname" & "Moviename" \\
\hline
"Apocalypse Now" & "1989" & "War" & "Marlon Brando" & "Apocalypse Now" \\
\hline
\end{tabular}

\section*{(Inner) Joins}
\begin{verbatim}
SELECT DISTINCT genre
FROM   Movie, ActedIN
WHERE  Movie.name=ActedIN.moviename AND ActedIN.actorname='Marlon Brando'
\end{verbatim}

\begin{tabular}{lll}
\hline
"Name" & "Year" & "Genre" \\
\hline
"Apocalypse Now" & "1979" & "War" \\
"The God Father" & "1972" & "Crime" \\
"Planet Earth II" & "2016" & "Nature Documentary" \\
\hline
\end{tabular}

\begin{tabular}{ll}
\hline
"Actorname" & "Moviename" \\
\hline
"Marlon Brando" & "Apocalypse Now" \\
"Al Pacino" & "The God Father" \\
"Marlon Brando" & "The God Father" \\
\hline
\end{tabular}

\begin{tabular}{lllll}
\hline
"Name" & "Year" & "Genre" & "Actorname" & "Moviename" \\
\hline
"Apocalypse Now" & "1989" & "War" & "Marlon Brando" & "Apocalypse Now" \\
\hline
\end{tabular}

\section*{(Inner) Joins}
\begin{verbatim}
SELECT DISTINCT genre
FROM   Movie, ActedIN
WHERE  Movie.name=ActedIN.moviename AND ActedIN.actorname='Marlon Brando'
\end{verbatim}

\begin{tabular}{lll}
\hline
"Name" & "Year" & "Genre" \\
\hline
"Apocalypse Now" & "1979" & "War" \\
"The God Father" & "1972" & "Crime" \\
"Planet Earth II" & "2016" & "Nature Documentary" \\
\hline
\end{tabular}

\begin{tabular}{ll}
\hline
"Actorname" & "Moviename" \\
\hline
"Marlon Brando" & "Apocalypse Now" \\
"Al Pacino" & "The God Father" \\
"Marlon Brando" & "The God Father" \\
\hline
\end{tabular}

\begin{tabular}{lllll}
\hline
"Name" & "Year" & "Genre" & "Actorname" & "Moviename" \\
\hline
"Apocalypse Now" & "1989" & "War" & "Marlon Brando" & "Apocalypse Now" \\
\hline
\end{tabular}

\section*{(Inner) Joins}
\begin{verbatim}
SELECT DISTINCT genre
FROM   Movie, ActedIN
WHERE  Movie.name=ActedIN.moviename AND ActedIN.actorname='Marlon Brando'
\end{verbatim}
Movie (name, year, genre)
ActedIN (actorname, moviename)

\begin{tabular}{lll}
\hline
Name & Year & Genre \\
\hline
Apocalypse Now & 1979 & War \\
The God Father & 1972 & Crime \\
Planet Earth II & 2016 & Nature Documentary \\
\hline
\end{tabular}

\begin{tabular}{ll}
\hline
Actorname & Moviename \\
\hline
Marlon Brando & Apocalypse Now \\
Al Pacino & The God Father \\
Marlon Brando & The God Father \\
\hline
\end{tabular}

\begin{tabular}{lllll}
\hline
Name & Year & Genre & Actorname & Moviename \\
\hline
Apocalypse Now & 1989 & War & Marlon Brando & Apocalypse Now \\
\hline
\end{tabular}

\section*{(Inner) Joins}
Movie (name, year, genre)
ActedIN (actorname, moviename)

\begin{tabular}{lll}
\hline
Name & Year & Genre \\
\hline
Apocalypse Now & 1979 & War \\
The God Father & 1972 & Crime \\
Planet Earth II & 2016 & Nature Documentary \\
\hline
\end{tabular}

\begin{tabular}{ll}
\hline
Actorname & Moviename \\
\hline
Marlon Brando & Apocalypse Now \\
Al Pacino & The God Father \\
Marlon Brando & The God Father \\
\hline
\end{tabular}

\begin{tabular}{lllll}
\hline
Name & Year & Genre & Actorname & Moviename \\
\hline
Apocalypse Now & 1989 & War & Marlon Brando & Apocalypse Now \\
The God Father & 1972 & Crime & Marlon Brando & The God Father \\
\hline
\end{tabular}
\begin{verbatim}
SELECT DISTINCT genre
FROM   Movie, ActedIN
WHERE  Movie.name= ActedIN.moviename AND ActedIN.actorname='Marlon 'Brando"
\end{verbatim}

\section*{(Inner) Joins}
Movie (name, year, genre)
ActedIN (actorname, moviename)

\begin{tabular}{lll}
\hline
Name & Year & Genre \\
\hline
Apocalypse Now & 1979 & War \\
The God Father & 1972 & Crime \\
Planet Earth II & 2016 & Nature Documentary \\
\hline
\end{tabular}

\begin{tabular}{ll}
\hline
Actorname & Moviename \\
\hline
Marlon Brando & Apocalypse Now \\
Al Pacino & The God Father \\
Marlon Brando & The God Father \\
\hline
\end{tabular}

\begin{tabular}{lllll}
\hline
Name & Year & Genre & Actorname & Moviename \\
\hline
Apocalypse Now & 1989 & War & Marlon Brando & Apocalypse Now \\
The God Father & 1972 & Crime & Marlon Brando & The God Father \\
\hline
\end{tabular}
\begin{verbatim}
SELECT DISTINCT genre
FROM   Movie, ActedIN
WHERE  Movie.name= ActedIN.moviename AND ActedIN.actorname='Marlon 'Brando"
\end{verbatim}

\section*{(Inner) Joins}
Movie (name, year, genre)
ActedIN (actorname, moviename)

\begin{tabular}{lll}
\hline
Name & Year & Genre \\
\hline
Apocalypse Now & 1979 & War \\
The God Father & 1972 & Crime \\
Planet Earth II & 2016 & Nature Documentary \\
\hline
\end{tabular}

\begin{tabular}{ll}
\hline
Actorname & Moviename \\
\hline
Marlon Brando & Apocalypse Now \\
Al Pacino & The God Father \\
Marlon Brando & The God Father \\
\hline
\end{tabular}
\begin{verbatim}
SELECT DISTINCT genre
FROM   Movie, ActedIN
WHERE  Movie.name= ActedIN.moviename AND ActedIN.actorname='Marlon 'Brando"
\end{verbatim}

\section*{(Inner) Joins}
Movie (name, year, genre)
ActedIN (actorname, moviename)

\begin{tabular}{lll}
\hline
Name & Year & Genre \\
\hline
Apocalypse Now & 1979 & War \\
The God Father & 1972 & Crime \\
Planet Earth II & 2016 & Nature Documentary \\
\hline
\end{tabular}

\begin{tabular}{ll}
\hline
Actorname & Moviename \\
\hline
Marlon Brando & Apocalypse Now \\
Al Pacino & The God Father \\
Marlon Brando & The God Father \\
\hline
\end{tabular}

\section*{Self Join}
Employee (eid, name, salary, managerid)

Find name of employees and the name of their managers

\begin{verbatim}
SELECT e.name, m.name
FROM   Employee e, Employee m
WHERE  e.managerid = m.eid
\end{verbatim}

\section*{Self Join}
Employee (eid, name, salary, managerid)

\begin{tabular}{llll}
\hline
eid & name & salary & managerid \\
\hline
101 & John & 50000 & 103 \\
102 & Alice & 60000 & 104 \\
103 & Mary & 80000 & NULL \\
104 & Bob & 80000 & 103 \\
\hline
\end{tabular}

\begin{tabular}{ll}
\hline
e.name & m.name \\
\hline
John & Mary \\
Alice & Bob \\
Bob & Mary \\
\hline
\end{tabular}

\section*{Outer Joins}
\begin{itemize}
    \item Left Outer Join
    \item Right Outer Join
    \item Full Outer Join
\end{itemize}

\section*{Outer Joins}

\section*{Left Outer Join}
\begin{verbatim}
SELECT Movie.name, ActedIN.actorname
FROM   Movie LEFT OUTER JOIN ActedIN
ON     Movie.name = ActedIN.moviename
\end{verbatim}

\begin{tabular}{ll}
\hline
Movie.name & ActedIN.actorname \\
\hline
Apocalypse Now & Marlon Brando \\
The God Father & Al Pacino \\
The God Father & Marlon Brando \\
Planet Earth II & NULL \\
\hline
\end{tabular}

\section*{Right Outer Join}
\begin{verbatim}
SELECT Movie.name, ActedIN.actorname
FROM   Movie RIGHT OUTER JOIN ActedIN
ON     Movie.name = ActedIN.moviename
\end{verbatim}

\begin{tabular}{ll}
\hline
Movie.name & ActedIN.actorname \\
\hline
Apocalypse Now & Marlon Brando \\
The God Father & Al Pacino \\
The God Father & Marlon Brando \\
NULL & Leonardo DiCaprio \\
\hline
\end{tabular}

\section*{Full Outer Join}
\begin{verbatim}
SELECT Movie.name, ActedIN.actorname
FROM   Movie FULL OUTER JOIN ActedIN
ON     Movie.name = ActedIN.moviename
\end{verbatim}

\begin{tabular}{ll}
\hline
Movie.name & ActedIN.actorname \\
\hline
Apocalypse Now & Marlon Brando \\
The God Father & Al Pacino \\
The God Father & Marlon Brando \\
Planet Earth II & NULL \\
NULL & Leonardo DiCaprio \\
\hline
\end{tabular}

\section*{Joins on More Than Two Tables}
\begin{verbatim}
SELECT DISTINCT name, genre, actorname
FROM   Movie, ActedIN
WHERE  Movie.name= ActedIN.moviename AND Movie.year > 1975
\end{verbatim}

\begin{tabular}{lll}
\hline
Name & Genre & Actorname \\
\hline
Apocalypse Now & War & Marlon Brando \\
\hline
\end{tabular}

\begin{verbatim}
SELECT DISTINCT name, genre, actorname
FROM   Movie, ActedIN
WHERE  Movie.name= ActedIN.moviename AND Movie.year > 1975
\end{verbatim}

\begin{tabular}{llllll}
\hline
"Name" & "Year" & "Genre" & "Budget" & "Revenue" & "Rate" \\
\hline
"Pirates of the Caribbean" & "2007" & "Action" & "\$300M" & "\$900M" & "7.1" \\
"The Lion King" & "2019" & "Animation" & "\$260M" & "\$1.65B" & "6.5" \\
"The Dark Knight" & "2008" & "Action" & "\$185M" & "\$1B" & "9.5" \\
"Toy Story 3" & "2010" & "Animation" & "\$300M" & "\$1B" & "8.3" \\
"American Sniper" & "2013" & "Action" & "\$59M" & "\$350M" & "7.3" \\
\hline
\end{tabular}

\section*{What type of summary statistics could be of interest?}

\section*{Aggregate Functions}

Five basic aggregate operations in SQL

COUNT counts how many rows are in a particular column. [cite: 61]
SUM adds together all the values in a particular column. [cite: 62, 63, 64]
MIN and MAX return the lowest and highest values in a particular column, respectively. [cite: 62, 63, 64]
AVG calculates the average of a group of selected values. [cite: 62, 63, 64]

Except count, all aggregations apply to a single attribute

\section*{EXAMPLE}

\begin{verbatim}
SELECT count (*)
FROM Movie

SELECT count (DISTINCT genre)
FROM   Movie

SELECT count (genre)
FROM   Movie
\end{verbatim}

We probably want this

\section*{Aggregates and NULL Values}

Null is ignored in any aggregation (It does not contribute to any aggregate)

\begin{tabular}{llllll}
\hline
"Name" & "Year" & "Genre" & "Budget" & "Revenue" & "Rate" \\
\hline
"Pirates of the Caribbean" & "2007" & "Action" & "\$300M" & "\$900M" & "7.1" \\
"The Lion King" & "2019" & "Animation" & "\$260M" & "\$1.65B" & "6.5" \\
"The Dark Knight Toy Story 3" & "2008 2010" & "Action Animation" & "\$185M \$300M" & "\$1B \$1B" & "9.5 8.3" \\
"American Sniper" & "2013" & "Action" & "\$59M" & "\$350M" & "7.3" \\
\hline
\end{tabular}

\section*{Aggregates and NULL Values}

Null is ignored in any aggregation (It does not contribute to any aggregate)

\begin{tabular}{llllll}
\hline
"Name" & "Year" & "Genre" & "Budget" & "Revenue" & "Rate" \\
\hline
"Pirates of the Caribbean" & "2007" & "Action" & "\$300M" & "\$900M" & "7.1" \\
"The Lion King" & "2019" & "Animation" & "\$260M" & "\$1.65B" & "6.5" \\
"The Dark Knight" & "2008" & "Action" & "NULL" & "NULL" & "9.5" \\
"Toy Story 3" & "NULL" & "Animation" & "\$300M" & "\$1B" & "8.3" \\
"American Sniper" & "2013" & "Action" & "\$59M" & "\$350M" & "7.3" \\
\hline
\end{tabular}

\begin{verbatim}
select count (*)
from   Movie

select count (*)
from   Movie

select count (year)
from   Movie

select sum (revenue)
from   Movie
where  revenue is not null
\end{verbatim}

\section*{Aggregates and NULL Values}

Null is ignored in any aggregation (It does not contribute to any aggregate)

\begin{tabular}{llllll}
\hline
"Name" & "Year" & "Genre" & "Budget" & "Revenue" & "Rate" \\
\hline
"Pirates of the Caribbean" & "2007" & "Action" & "\$300M" & "\$900M" & "7.1" \\
"The Lion King" & "2019" & "Animation" & "\$260M" & "\$1.65B" & "6.5" \\
"The Dark Knight" & "2008" & "Action" & "NULL" & "NULL" & "9.5" \\
"Toy Story 3" & "NULL" & "Animation" & "\$300M" & "\$1B" & "8.3" \\
"American Sniper" & "2013" & "Action" & "\$59M" & "\$350M" & "7.3" \\
\hline
\end{tabular}

\begin{verbatim}
select count (*)
from   Movie

select count (*)
from   Movie

select count (year)
from   Movie

select sum (revenue)
from   Movie
where  revenue is null
\end{verbatim}

\section*{Grouping and Aggregation}

Movie (name, year, genre, budget, rate, revenue)

Find the total revenue for all movies produced after 2008 by genre

\begin{tabular}{llll}
\hline
"Name" & "Year" & "Genre" & "Revenue" \\
\hline
"Pirates of the Caribbean" & "2007" & "Action" & "\$900M" \\
"The Lion King" & "2019" & "Animation" & "\$1.65B" \\
"The Dark Knight" & "2008" & "Action" & "\$1B" \\
"Toy Story 3" & "2010" & "Animation" & "\$1B" \\
"American Sniper" & "2013" & "Action" & "\$350M" \\
\hline
\end{tabular}

\begin{verbatim}
SELECT genre, Sum(revenue) AS Total Revenue
FROM   Movie
WHERE  year > 2008
GROUP BY genre
\end{verbatim}

\begin{tabular}{llll}
\hline
"Name" & "Year" & "Genre" & "Revenue" \\
\hline
"Toy Story 3" & "2010" & "Animation" & "\$900M" \\
"The Lion King" & "2019" & "Animation" & "\$1.65B" \\
"Pirates of the Caribbean" & "2007" & "Action" & "\$1B" \\
"The Dark Knight" & "2008" & "Action" & "\$1B" \\
"American Sniper" & "2013" & "Action" & "\$350M" \\
\hline
\end{tabular}

\begin{verbatim}
SELECT genre, Sum(revenue) AS Total Revenue
FROM   Movie
WHERE  year > 2008
GROUP BY genre
\end{verbatim}

Grouping and Aggregation Name Year Genre Revenue Toy Story 3 2010 Animation \$900M The Lion King 2019 Animation \$1.65B Pirates of the Caribbean 2007 Action \$1B The Dark Knight 2008 Action \$1B American Sniper 2013 Action \$350M SELECT genre, Sum(revenue) AS TotalRevenue FROM Movie WHERE year > 2008 GROUP BY genre

\begin{tabular}{ll}
\hline
Genre & Total Revenue \\
\hline
Animation & \$2.65B \\
Action & \$1.35B \\
\hline
\end{tabular}

\section*{Other Examples}

Compare these two queries: SELECT genre, Sum(revenue) AS TotalRevenue FROM Movie GROUP BY genre SELECT genre, Sum(revenue) AS TotalRevenue FROM Movie GROUP BY year One answer for each year One answer for each genre Other Examples SELECT year sum(budget) AS SumBudget, max(revenue) AS MaxRevenue FROM movie GROUP BY year Mix and match aggregates Multiple Aggregates SELECT genre, Sum(revenue - budget) AS TotalProfit FROM Movie GROUP BY genre, year Multiple grouping attribute Other Examples Name Year Genre Revenue Toy Story 3 2010 Animation \$900M The Lion King 2019 Animation \$1.65B Pirates of the Caribbean 2007 Action \$1B The Dark Knight 2008 Action \$1B American Sniper 2013 Action \$350M Genre Revenue Animation \$2.55B Action \$2.35B SELECT genre, Sum(revenue) FROM Movie WHERE year > 2008 GROUP BY genre Other Examples Everything in SELECT must be either a GROUP BY attribute, or an aggregate Name

\newpage

\section*{What We Have Learned So Far}

\begin{itemize}
\item Data models
\item Relational data model
\item Structure
\item Complaints
\item Manipulation: SQL
\end{itemize}

\section*{What We Have Learned So Far}

SQL Features

\begin{itemize}
\item Projections
\item Selections
\item Joins (inner and outer)
\item Group by
\item Having
\item Inserts, updates,
\item Aggregates
\item and deletes
\end{itemize}

\section*{Subqueries}

\begin{itemize}
\item Subquery: A query that is part of another
\item Nested Query: A query that has an embedded subquery
\item A subquery can be nested query itself!
\end{itemize}

Why?
Sometimes we need to express a condition that refers to a table that must itself be computed

A subquery may occur in:

\begin{itemize}
\item A SELECT clause
\item A FROM clause
\item A WHERE clause
\end{itemize}

Often appear here

Rule of thumb: avoid nested queries when possible

(But sometimes it's impossible, as we will see)

\section*{Subqueries}

\begin{itemize}
\item Can return a single value to be included in a SELECT clause
\item Can return a relation to be included in the FROM clause
\item Can return a single value to be compared with another value in a WHERE clause
\item Can return a relation to be used in the WHERE or HAVING
\end{itemize}

\section*{1. Subqueries in SELECT}

Movie(name, year, genre, budget, revenue, rating)

ActedIN (actorname, moviename, salary)

\section*{1.Subqueries in SELECT}

Movie (name, year, genre, budget, revenue, rating) ActedIN (actorname, moviename, salary)

For each actor return the genre of movie they acted in

\begin{verbatim}
SELECT a.actorname, (SELECT genre
FROM   Movie m
WHERE  $m.name=a.moviename)$ as genre
FROM   ActedIn a
\end{verbatim}

"Correlated subquery"

What happens if the subquery returns more than one genre?

\section*{1.Subqueries in SELECT}

Movie (name, year, genre, budget, revenue, rating) ActedIN (actorname, moviename, salary)

Whenever possible, don't use a nested queries:

\begin{verbatim}
SELECT a.actorname, (SELECT genre
FROM   Movie m
WHERE  m.name = a.moviename) as genre
FROM   ActedIn a
\end{verbatim}

\begin{verbatim}
"SELECT
","a.actorname, genre
"
"FROM
","ActedIn a, Movie m
"
"WHERE
","m.name = a.moviename
"
\end{verbatim}

Subquery unnesting

\section*{1.Subqueries in SELECT}

Movie (name, year, genre, budget, revenue, rating) ActedIN (actorname, moviename, salary)

Compute average salary of actors for all movies with rating >9

\begin{verbatim}
SELECT DISTINCT m.name, (SELECT AVG (salary)
FROM   ActedIn a
WHERE  m.name = a.moviename) as salary
FROM   Movie.m
WHERE  m.rating >9
\end{verbatim}

\begin{verbatim}
"SELECT
","m.name, AVG(salary)
"
"FROM
","Movie m, ActedIn a
"
"WHERE
","m.name=a.moviename
"
"AND
","m.rating> 9
"
"GROUP BY
","m.name
"
\end{verbatim}

Subquery unnesting

\section*{1.Subqueries in SELECT}

Movie (name, year, genre, budget, revenue, rating) ActedIN (actorname, moviename, salary)

Compute the number of actors in each movie

\begin{verbatim}
SELECT DISTINCT m.name, (SELECT count (*)
FROM   ActedIn a
WHERE  m.name = a.moviename) as anum
FROM   Movie.m
\end{verbatim}

?

\begin{verbatim}
SELECT
FROM   m.name, count(*)
       ActedIn a, Movie m
WHERE  m.name=a.moviename
GROUP BY m.name
\end{verbatim}

Subquery unnesting

\section*{1.Subqueries in SELECT}

But are these equivalent?

\begin{verbatim}
SELECT DISTINCT m.name, (SELECT AVG (salary)
FROM   ActedIn a
WHERE  m.name = a.moviename ) as salary
FROM   Movie.m
WHERE  m.rating >9
\end{verbatim}

Movie (name, year, genre, budget, revenue , rating) ActedIN (actorname, moviename, salary)

\begin{verbatim}
SELECT m.name, AVG(salary)
FROM   Movie m, ActedIn a
WHERE  m.name=a.moviename AND m.rating> 9
GROUP BY m.name
=
SELECT m.name, AVG(salary)
FROM   Movie m, LEFT OUTER JOIN ActedIn a
ON     m.name=a.moviename
WHERE  rating> 9
GROUP BY m.name
=
\end{verbatim}

\section*{2. Subqueries in FROM}

Movie(name, year, genre, budget, revenue , rating) ActedIN (actorname, moviename, salary)

\section*{2.Subqueries in FROM}

Find all Movie with rating > 8 and < 9 "Not a correlated subquery"

Movie (name, year, genre, budget, revenue , rating) ActedIN (actorname, moviename, salary)

\begin{verbatim}
SELECT x.name, rating
FROM   (SELECT *
        FROM   Movie AS m
        WHERE  rating > 8) as x
WHERE  x.rating <9
\end{verbatim}

\begin{verbatim}
WITH myTable AS (SELECT * FROM Movie AS m WHERE rating > 8)
SELECT x.name, x.rating
FROM   myTable as X
WHERE  x.rating < 9
\end{verbatim}

A subquery whose result we called myTable Sub-query refactoring

\section*{2.Subqueries in FROM}

Find all Movie with rating > 8 and < 9 Movie (name, year, genre, budget, revenue , rating) ActedIN (actorname, moviename, salary)

\begin{verbatim}
SELECT x.name. rating
FROM   (SELECT *
        FROM   Movie AS m
        WHERE  rating > 8) as x
WHERE  x.rating < 9
\end{verbatim}

\begin{verbatim}
SELECT m.name, rating
FROM   myTable as X
WHERE  m.rating < 9 AND m.rating > 8
=
\end{verbatim}

Subquery unnesting

\section*{3. Subqueries in WHERE}

Movie(name, year, genre, budget, revenue , rating) ActedIN (actorname, moviename, salary)

\section*{3.Subqueries in WHERE}

Find the name of actors who have acted in some Sci-Fi movie

\begin{itemize}
\item Existential Quantifiers
\item Quantifier is a logical operator that specifies how many elements in the domain of discourse satisfy a property
\item "There exists," "there is at least one," or "for some"
\end{itemize}

Movie (name, year, genre, budget, revenue , rating) ActedIN (actorname, moviename, salary)

\begin{verbatim}
SELECT DISTINCT a.actorname
FROM   ActedIn a
WHERE  EXISTS ( SELECT m.name
               FROM   Movie m
               WHERE  m.name=a.moviename AND
                      m.genre='Sci-Fi')
\end{verbatim}

TRUE if the subquery Using EXISTS returns one or more records

\section*{3.Subqueries in WHERE}

Find the name of actors who have acted in some Sci-Fi movie Movie (name, year, genre, budget, revenue , rating) ActedIN (actorname, moviename, salary)

\begin{verbatim}
SELECT DISTINCT a.actorname
FROM   ActedIn a
WHERE  a.moviename IN (SELECT m.name
                      FROM   Movie m
                      WHERE  m.name=a.moviename AND
                             m.genre='Sci-Fi')
\end{verbatim}

Allow us to test set Using IN membership Existential Quantifiers

\section*{3.Subqueries in WHERE}

Find the name of actors who have acted in some Sci-Fi movie Movie (name, year, genre, budget, revenue , rating) ActedIN (actorname, moviename, salary)

\begin{verbatim}
SELECT DISTINCT a.actorname
FROM   ActedIn a
WHERE  a.moviename IN (SELECT m.name
                      FROM   Movie m
                      WHERE  m.name=a.moviename AND
                             m.genre='Sci-Fi')
\end{verbatim}

Existential Quantifiers

\begin{verbatim}
SELECT DISTINCT a.actorname Subquery unnesting
FROM   Movie m, ActedIN a
WHERE  m.name=a.moviename AND m.genre='Sci-Fi'
\end{verbatim}

\section*{3.Subqueries in WHERE}

Find the name of actors who have acted in some non-Sci-Fi movie Movie (name, year, genre, budget, revenue , rating) ActedIN (actorname, moviename, salary)

\begin{verbatim}
SELECT DISTINCT a.actorname
FROM   ActedIn a
WHERE  a.moviename NOT IN (SELECT m.name
                          FROM   Movie m
                          WHERE  m.name=a.moviename AND
                                 m.genre='Sci-Fi')
\end{verbatim}

Existential Quantifiers

\begin{verbatim}
SELECT DISTINCT a.actorname
FROM   movie m, ActedIN a
WHERE  m.name=a.moviename AND m.genre $\neq$'Sci-Fi'
\end{verbatim}

Subquery unnesting

\section*{Existential Quantifiers}

are easy J

Join queries essentially check for existential quantifiers

Universal Quantifiers are hard L

The SQL constructs we have discussed so far do not capture universal quantifiers

GOOD NEWS BAD NEWS

\section*{3.Subqueries in WHERE}

Retrieve all actor names that only acted on action movies

\begin{itemize}
\item Universal Quantifiers
\item "Given any," "for all," or "for every"
\item Same as every movies they acted on were action
\end{itemize}

Movie (name, year, genre, budget, revenue , rating) ActedIN (actorname, moviename, salary)

\begin{verbatim}
SELECT DISTINCT a.name
FROM   ActedIn a
WHERE  a.moviename NOT IN (SELECT a.actorname
                          FROM   Movie m, ActedIn a
                          WHERE  m.name=a.moviename AND
                                 m.genre $\neq$ 'Action')
\end{verbatim}

\begin{itemize}
\item Step 1: Find all actor names that acted on some non-action movie
\item Step 2: Retrieve all the others (i.e., those do not satisfy the result of Step 1.)
\end{itemize}

\section*{3.Subqueries in WHERE}

Retrieve all actor names that only acted on action movies Movie (name, year, genre, budget, revenue , rating) ActedIN (actorname, moviename, salary)

\begin{verbatim}
SELECT a.name
FROM   ActedIn a
WHERE  a.moviename NOT IN (SELECT a.actorname
                          FROM   Movie m, ActedIn a
                          WHERE  m.name=a.moviename AND
                                 m.genre $\neq$ 'Action')
\end{verbatim}

\begin{itemize}
\item Step 1: Find all actor names that acted on some non-action movie
\item Step 2: Retrieve all the others i.e., those do not satisfy the result of Step 1.
\end{itemize}


\begin{itemize}
\item Universal Quantifiers
\item "Given any," "for all," or "for every"
\item Same as every movies they acted on were action
\end{itemize}

\section*{3.Subqueries in WHERE}

Retrieve all actor names that acted on at most two action movies Movie (name, year, genre, budget, revenue , rating) ActedIN (actorname, moviename, salary)

\begin{verbatim}
SELECT DISTINCT a.actorname
FROM   ActedIn a
WHERE  2 >= (SELECT count (*)
             FROM   Movie m
             WHERE  m.name=a.moviename AND
                    m.genre = 'Action')
\end{verbatim}

What does this query do?

\section*{3.Subqueries in WHERE}

\begin{verbatim}
SELECT DISTINCT a.actorname
FROM   ActedIn a
WHERE  0 < (SELECT count (*)
            FROM   Movie m
            WHERE  m.name=a.moviename AND
                   m.genre = 'Action')
\end{verbatim}

Find all movie s.t.

\section*{3.Subqueries in WHERE}

all their actors' salaries > \$100K Movie (name, year, genre, budget, revenue , rating) ActedIN (actorname, moviename, salary)

\begin{verbatim}
SELECT m.name
FROM   movie m
WHERE  $100K < ALL (SELECT a.salary
                   FROM   ActedIn a
                   WHERE  m.name=a.moviename)
\end{verbatim}

Not supported in SQLite Universal Quantifiers Is it possible to unnest the universal quantifier query?

\section*{Unnesting Universal}

Is it possible to unnest the universal quantifier query?

\section*{Unnesting Universal}

\begin{itemize}
\item A query Q is monotone if:
\item Whenever we add tuples to one or more input tables, the answer to the query will not lose any output tuple.
\end{itemize}

\section*{Unnesting Universal Quantifiers}

\begin{verbatim}
SELECT a.actorname
FROM   Movie m, ActedIn a
WHERE  m.name=a.moviename AND m.gendre='Crime'
\end{verbatim}

Is this monotone?

\section*{Monotone Queries}

\begin{tabular}{llll}
\hline
Name & Year & Genre &  \\
\hline
Apocalypse Now & 1989 & War &  \\
The God Father & 1972 & Crime &  \\
Planet Earth II & 2016 & Nature Documentary &  \\
Jack and Jill & 2011 & Comedy &  \\
\hline
\end{tabular}

\begin{tabular}{ll}
\hline
Actorname &  \\
\hline
Marlon Brando &  \\
Al Pacino &  \\
\hline
\end{tabular}

\begin{verbatim}
SELECT a.actorname
FROM   Movie m, ActedIn a
WHERE  m.name=a.moviename AND m.gendre='Crime'
\end{verbatim}

\section*{Data Models}

A data model is an abstraction for describing and representing data[cite: 2].

The description consists of three parts:

\begin{itemize}
    \item Structure
    \item Constraints
    \item Manipulation
\end{itemize}

\section*{Important Data Models}

\begin{itemize}
    \item Relational: Data represented as a collection of tables
    \item Semistructured: Data represented as a tree
    \item Key-value pairs: Data represented as a dictionary or Hash table
    \item Graph
    \item Array/Matrix
    \item Dataframes
\end{itemize}

Most Database Systems (Our focus) [cite: 3, 4]

NoSQL database systems [cite: 5]

Machine Learning [cite: 6]

\section*{The Relational Data Model}

\begin{itemize}
    \item Structure
    \item Constraints
    \item Manipulation
\end{itemize}

\section*{The Relational Data Model}

Data is a collection of relations[cite: 9].

A relation is a table that consists of a set of tuples or records[cite: 9].

\section*{The Relational Data Model}

Attribute (Field, Column) is atomic typed data entry[cite: 13, 14, 15].

Attribute domain

Attribute name

\begin{tabular}{lllll}
\hline
SID & Name & Surname & Age & GPA \\
\hline
1 & Alicia & Shan & 20 & 3.5 \\
2 & Andre & Lorde & 21 & 3 \\
3 & Yan & Ke & 19 & 4 \\
4 & Sudip & Roy & 22 & 4 \\
\hline
\end{tabular}

Atomic Types

Characters: CHAR(20), VARCHAR(50)

Numbers: INT, BIGINT, SMALLINT, FLOAT

Others: MONEY, DATETIME

Integer

Relational Schema

Describes the relation's name, attribute name, and their domain name (metadata)

Student (sid: string, name: string, username: string, age: integer, gpa: real)

\begin{tabular}{lllll}
\hline
SID & Name & Surname & Age & GPA \\
\hline
1 & Alicia & Shan & 20 & 3.5 \\
2 & Andre & Lorde & 21 & 3 \\
3 & Yan & Ke & 19 & 4 \\
4 & Sudip & Roy & 22 & 4 \\
\hline
\end{tabular}

\begin{tabular}{lllll}
\hline
SID & Name & Username & Age & GPA \\
\hline
1 & Alicia & Shan & 20 & 3.5 \\
2 & Andre & Lorde & 21 & 3 \\
3 & Yan & Ke & 19 & 4 \\
4 & Sudip & Roy & 22 & 4 \\
\hline
\end{tabular}

Tuple (Record, Column) is a single entry in the table[cite: 16].

Relational Instance

Is a set of tuples conforming to the same schema (data) [cite: 16]

Cardinality is the number of tuples in a relation[cite: 17].

Arity is the number of attributes of a relation[cite: 17].

Arity = 5

Cardinality = 4

\begin{tabular}{lllll}
\hline
SID & Name & Surname & Age & GPA \\
\hline
1 & Alicia & Shan & 20 & 3.5 \\
2 & Andre & Lorde & 21 & 3 \\
3 & Yan & Ke & 19 & 4 \\
4 & Sudip & Roy & 22 & 4 \\
\hline
\end{tabular}

\section*{The Relational Data Model}

\begin{itemize}
    \item Structure
    \item Constraints
    \item Manipulation
\end{itemize}

\section*{Integrity Constraints}

Data is only as good as information stored in it[cite: 19].

The relational data model allows us to impose various constraints on data[cite: 19].

Integrity Constraints (IC): is a condition specified on a database schema and restrict the data that can be stored in an instance[cite: 19].

We've already discussed one IC: Domain Constraints! [cite: 19]

\begin{tabular}{lllll}
\hline
SID & Name & Surname & Age & GPA \\
\hline
1 & Alicia & Shan & 20 & 3.5 \\
2 & Andre & Lorde & 21 & 3 \\
3 & Yan & Ke & 19 & 4 \\
4 & Sudip & Roy & 22 & 4 \\
\hline
\end{tabular}

Key Constraint: a statement that a minimal subset of attributes uniquely identify a tuple[cite: 20, 21, 22, 23].

(Candidate) Key: a set of attributes that uniquely identify a tuple[cite: 20, 21, 22, 23].

Not a key

Is this a key?

Composite Key What does it mean?

Key

No two students have the same ID

\begin{tabular}{lllll}
\hline
SID & Name & Surname & Age & GPA \\
\hline
1 & Alicia & Shan & 20 & 3.5 \\
2 & Andre & Lorde & 21 & 3 \\
3 & Yan & Ke & 19 & 4 \\
4 & Sudip & Roy & 22 & 4 \\
\hline
\end{tabular}

Super Key: a set of attributes that contain a key[cite: 24, 25].

A relation may have several candidate keys[cite: 24, 25].

Primary Key: a database designer identify one key and designate it as primary key[cite: 24, 25].

Key

Another Key

Student (sid, name, surname, age, gpa)

Primary key = sid

Student (sid, name, surname, age, gpa)

Primary key = name, username

Student (sid, name, surname, age, gpa)

Enrolled (cid, sid, grade)

Sometimes data stored in a relation is linked to data stored in another relation[cite: 26].

If one of the relations are modified the other should be checked for consistency[cite: 26].

Foreign Key Constraint

Foreign Key Constraint

Student (sid, name, username, age, gpa)

Enrolled (cid, sid, grade)

\begin{tabular}{lllll}
\hline
SID & Name & Surname & Age & GPA \\
\hline
1 & Alicia & Shan & 20 & 3.5 \\
2 & Andre & Lorde & 21 & 3 \\
\hline
\end{tabular}

\begin{tabular}{lll}
\hline
CID & SID & Grade \\
\hline
dsc100 & 1 & 92 \\
dsc80 & 2 & 90 \\
\hline
\end{tabular}

Student

Enrolled

It can have a different name

\section*{The Relational Data Model}

\begin{itemize}
    \item Structure
    \item Constraints
    \item Manipulation
\end{itemize}

\section*{Query Language}

Specialized languages for asking questions, or queries from relational data[cite: 29].

\begin{itemize}
    \item Commercial: SQL (Structured Query Language) [cite: 29]
    \item Formal: Relational algebra, Relational calculus [cite: 29]
\end{itemize}

SQL

Data Definition Language (DDL)

Create / alter / delete tables and their attributes - discussed next! [cite: 30]

Manipulating Schema

Manipulating Data Data Manipulation Language (DML) [cite: 31]

\section*{SQL: Quick Overview}

The CREATE TABLE statement is used to create a new table in a database[cite: 32].

\begin{verbatim}
CREATE TABLE table_name (
attribute1 type,
attribute2 type,
attribute3 type,
....
)
\end{verbatim}

\begin{verbatim}
CREATE TABLE Students(
sid CHAR(20),
name CHAR(30),
surname CHAR(20),
 age INTEGER
)
\end{verbatim}

\section*{SQL: Quick Overview}

The INSERT INTO statement is used to insert new records in a table[cite: 33].

\begin{verbatim}
INSERT INTO table_name (column1, column2, ...)
VALUES (value1, value2, ...)
\end{verbatim}

\begin{verbatim}
INSERT INTO table_name
VALUES (value1, value2, ...)
\end{verbatim}

Drop column names if you add values to all columns (be careful with the order)

\section*{SQL: Quick Overview}

The DELETE statement is used to delete existing records in a table[cite: 34].

\begin{verbatim}
DELETE FROM table_name WHERE condition
\end{verbatim}

\begin{verbatim}
DELETE FROM Students WHERE name='Ziaho'
\end{verbatim}

\section*{SQL: Quick Overview}

The UPDATE statement is used to modify the existing records in a table[cite: 35, 36].

\begin{verbatim}
UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition;
\end{verbatim}

\begin{verbatim}
UPDATE Students
SET gpa=gpa+3
WHERE name='Ziaho'
\end{verbatim}

\section*{SQL: Quick Overview}

The DROP TABLE statement is used to drop an existing table in a database[cite: 37, 38].

\begin{verbatim}
DROP TABLE table_name;
\end{verbatim}

\begin{verbatim}
DROP TABLE Student;
\end{verbatim}

\section*{SQL: Quick Overview}

The ALTER TABLE statement is used to add, delete, or modify columns in an existing table[cite: 39, 40].

\begin{verbatim}
ALTER TABLE table_name;
\end{verbatim}

\begin{verbatim}
ADD column1 type, column2 type,â€¦
ALTER TABLE Student
ADD Email varchar(255)
\end{verbatim}

\section*{SQL: Quick Overview}

The SELECT statement is used to select data from a database[cite: 41, 42].

\begin{verbatim}
SELECT column1, column2, ...
FROM table_name;
\end{verbatim}

\begin{verbatim}
SELECT name, gpa
FROM student
\end{verbatim}

\section*{SQL: Quick Overview}

The WHERE clause is used to filter records[cite: 43, 44].

\begin{verbatim}
SELECT column1, column2, ...
FROM table_name
WHERE condition;
\end{verbatim}

\begin{verbatim}
SELECT *
FROM student
WHERE age < 22;
\end{verbatim}

\begin{tabular}{lllll}
\hline
SID & Name & Surname & Age & GPA \\
\hline
1 & Alicia & Shan & 20 & 3.5 \\
2 & Andre & Lorde & 21 & 3 \\
3 & Yan & Ke & 19 & 4 \\
4 & Sudip & Roy & 22 & 4 \\
\hline
\end{tabular}

How would you implement this? [cite: 45]

The logical definition of the data remains unchanged, even when we make changes to the actual implementation[cite: 46].

Physical Data Independence

All relations must be flat: we say that the relation is in first normal form[cite: 47].

\begin{tabular}{lllll}
\hline
SID & Name & Surname & Age & GPA \\
\hline
1 & Alicia & Shan & 20 & 3.5 \\
2 & Andre & Lorde & 21 & 3 \\
\hline
\end{tabular}

First Normal Form

How can we store nested information? e.g., suppose we want to add courses enrolled by each student [cite: 48]

\begin{tabular}{lllll}
\hline
SID & Name & Surname & Age & GPA \\
\hline
1 & Alicia & Shan & 20 & 3.5 \\
2 & Andre & Lorde & 21 & 3 \\
\hline
\end{tabular}

All relations must be flat: we say that the relation is in first normal form[cite: 48].

E.g., we want to add courses enrolled by each student [cite: 49, 50]

\begin{tabular}{lllll}
\hline
SID & Name & Surname & Age & Enrolled \\
\hline
1 & Alicia & Shan & 20 &  \\
2 & Andre & Lorde & 21 &  \\
\hline
\end{tabular}

\begin{tabular}{ll}
\hline
CID & Grade \\
\hline
dsc100 & 97 \\
dsc80 & 90 \\
\hline
\end{tabular}

\begin{tabular}{ll}
\hline
CID & Grade \\
\hline
dsc100 & 91 \\
\hline
\end{tabular}

Non-1NF!

\begin{tabular}{lllll}
\hline
SID & Name & Surname & Age & GPA \\
\hline
1 & Alicia & Shan & 20 & 3.5 \\
2 & Andre & Lorde & 21 & 3 \\
\hline
\end{tabular}

Student

\begin{tabular}{lll}
\hline
CID & SID & Grade \\
\hline
dsc100 & 1 & 97 \\
dsc80 & 1 & 90 \\
dsc100 & 2 & 91 \\
\hline
\end{tabular}

Enrolled

Now it's in 1NF [cite: 51]

\section*{Data Models Summary}

Structure + Constraints + Manipulation [cite: 52]

Relational Model:

\begin{itemize}
    \item Database = collection of tables [cite: 52]
    \item Each table is flat: "first normal form" [cite: 52]
    \item Key: may consist of multiple attributes [cite: 52]
    \item Foreign key: "Semantic pointer" [cite: 52]
    \item Physical data independence [cite: 52]
\end{itemize}

\section*{The DataFrame Data Model}

\begin{itemize}
    \item 1992: Emerged S programming language emerged at Bell Labs
    \item 2000: Inherited by R programming language
    \item 2009: Brought to Python by Pandas
\end{itemize}

\section*{The DataFrame Data Model}

Support relational operator (e.g., filter, join), linear algebra (e.g., transpose), and spreadsheet-like (e.g., pivot) operators.

\begin{tabular}{lllll}
\hline
Name & FName & City & Age & Salary \\
\hline
Smith & John & 3 & 35 & \$280 \\
Doe & Jane & 1 & 28 & \$325 \\
Brown & Scott & 3 & 41 & \$265 \\
Howard & Shemp & 4 & 48 & \$359 \\
Taylor & Tom & 2 & 22 & \$250 \\
\hline
\end{tabular}

\section*{The DataFrame Model}

In Comparison to Relational Tables:

\begin{itemize}
    \item Lazily-induced schema
    \item Rows are named and ordered
    \item Heterogenous
\end{itemize}

In Comparison to Matrices:

\begin{itemize}
    \item Rows and columns are labeled
    \item Columns and rows equivalent
\end{itemize}

\section*{SQL Core Concepts}

\section*{Summary}
SQL (Structured Query Language) is the standard language for interacting with relational databases. It supports:
\begin{itemize}
    \item Data Definition Language (DDL): Creating, altering, and deleting tables and attributes (Lines: 9-11, 32-40)
    \item Data Manipulation Language (DML): Inserting, updating, deleting, and querying data (Lines: 12-13, 33-36, 41-44)
    \item Querying: Using SELECT statements with projection, selection, joins, grouping, and aggregation (Lines: 20-26, 248-266, 296-340)
    \item Constraints: Enforcing data integrity via keys and foreign keys (Lines: 671-700)
\end{itemize}

\section*{Core Concept Example}

\subsection*{Basic Aggregation and GROUP BY}
\begin{verbatim}
SELECT genre, SUM(revenue) AS TotalRevenue
FROM Movie
WHERE year > 2008
GROUP BY genre
\end{verbatim}
\textit{Finds the total revenue for all movies produced after 2008, grouped by genre.} (Lines: 296-340)

\subsection*{Derived Example: HAVING Clause}
\textit{The HAVING clause is used to filter groups after aggregation.}
\begin{verbatim}
SELECT genre, COUNT(*) AS MovieCount
FROM Movie
GROUP BY genre
HAVING COUNT(*) > 2
\end{verbatim}
\textit{This query returns genres with more than two movies.}
\textbf{Note: This is a derived example based on the GROUP BY and aggregation principles in Lines: 296-340. The HAVING clause is not explicitly shown in the source.}

\subsection*{Derived Example: Multiple Aggregates with HAVING}
\begin{verbatim}
SELECT genre, AVG(rating) AS AvgRating, SUM(revenue) AS TotalRevenue
FROM Movie
GROUP BY genre
HAVING AVG(rating) > 8.0
\end{verbatim}
\textit{Returns genres where the average rating is above 8.0.}
\textbf{Note: Derived from aggregation and grouping concepts in Lines: 248-340.}

\section*{Key Points}
\begin{itemize}
    \item SQL queries can project, filter, join, group, and aggregate data (Lines: 20-26, 248-340)
    \item GROUP BY is used to aggregate data by one or more columns (Lines: 296-340)
    \item HAVING filters groups after aggregation (Derived from SQL standards; not explicitly in the document)
    \item Aggregates ignore NULL values (Lines: 267-295)
    \item All columns in SELECT must be either grouped or aggregated (Lines: 296-340)
\end{itemize}

\section*{DataFrame Core Concepts}

\section*{Summary}
DataFrames are a tabular data structure supporting relational, linear algebra, and spreadsheet-like operations. They are widely used in data science and analytics, with origins in S, R, and Python's pandas library. (Lines: 702-720)

\section*{Core Concept Example}

\subsection*{Basic DataFrame Operations}
\begin{verbatim}
# Filtering rows where Age > 30
df_filtered = df[df['Age'] > 30]

# Grouping and aggregating
df_grouped = df.groupby('City')['Salary'].mean()
\end{verbatim}
\textit{These operations correspond to SQL selection and aggregation.} (Derived from DataFrame features in Lines: 702-730)

\subsection*{Derived Example: Advanced DataFrame Operations}
\begin{verbatim}
# Pivot table: Average Salary by City and Age Group
df['AgeGroup'] = pd.cut(df['Age'], bins=[20, 30, 40, 50], labels=['20-30', '31-40', '41-50'])
pivot = df.pivot_table(values='Salary', index='City', columns='AgeGroup', aggfunc='mean')

# Merging DataFrames (similar to SQL JOIN)
merged = pd.merge(df1, df2, left_on='SID', right_on='SID', how='inner')
\end{verbatim}
\textit{These advanced operations illustrate DataFrame capabilities beyond basic SQL.}
\textbf{Note: These are derived examples based on DataFrame principles in Lines: 702-730.}

\section*{Key Points}
\begin{itemize}
    \item DataFrames support relational (filter, join), linear algebra (transpose), and spreadsheet-like (pivot) operations (Lines: 702-720)
    \item Schema is often inferred from data (lazily-induced) (Lines: 721-730)
    \item Rows and columns are labeled and can be heterogeneous (Lines: 721-730)
    \item Advanced operations include pivot tables, merges (joins), and groupby-aggregate patterns (Derived from DataFrame model description)
\end{itemize}

\end{document}